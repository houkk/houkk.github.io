<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[helm -- kubernets 的包管理工具]]></title>
    <url>%2F2018%2F01%2F16%2Fk8s%2Fhelm-md%2F</url>
    <content type="text"><![CDATA[Helm 是 Kubernetes 的一个包管理工具，用来简化 Kubernetes 应用的部署和管理。可以把 Helm 比作 CentOS 的 yum 工具， 而我们的服务可以看作是 rpm 包。 1. 基本概念1）Chart: 是 Helm 管理的安装包，里面包含需要部署的安装包资源2）Release：是 chart 的部署实例，一个 chart 在一个 Kubernetes 集群上可以有多个 release，即这个 chart 可以被安装多次3）Repository：chart 的仓库，用于发布和存储 chart 2. 组成Helm 是 C/S 架构， 有 client 和 server 构成。tiller(server): 运行在 Kubernetes 集群上;helm(client,命令行工具)：可在本地运行，一般运行在CI/CD Server上 3. 安装 和 初始化安装教程， 以及初始化教程， 可以参考 helm github install.md 4. role-based access control(基于角色的访问控制)在 Kubernetes 1.8，Kubernetes APIServer 正式开启了RBAC访问控制，所以我们需要创建 tiller 使用的service account: tiller 并分配合适的角色给它。本文不多做说明， 关于如何配置请参考tiller and RBAC。至于 RBAC， 可以参考 Hands on with RBAC in Kubernetes 1.8 5. 基本使用5.1 创建 chart12345678910111213$ helm tree hello-world hello-world├── charts├── Chart.yaml├── templates│ ├── deployment.yaml│ ├── _helpers.tpl│ ├── ingress.yaml│ ├── NOTES.txt│ └── service.yaml└── values.yaml2 directories, 7 files charts: 本chart依赖的chart，当前是空的;Chart.yaml: 基本信息1234apiVersion: v1description: A Helm chart for Kubernetesname: microserviceversion: 0.1.0templates: 资源定义文件（serverce， deployment ..etc）values.yaml: chart 配置默认值， 在 templates 文件中调用 5.2 安装直接在上文创建出来的 hello-world chat 目录下， 执行helm install ./查看 release：helm list删除 release： helm delete release-name 5.3 打包分发12$ helm package ./Successfully packaged chart and saved it to: /home/work/kube/helm/hello-world/hello-world-0.1.0.tgz 同样可以根据此 tgz 包来进行安装、回滚、升级123$ helm install hello-world-0.1.0.tgz$ helm rollback releasename 1 # releasename 由 helm list 获得， 回滚前一个版本$ helm upgrade releasename . # 更新过 chart 并且 package 后， upgrade 替代 install 命令， 进行更新]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>helm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubernetes入门]]></title>
    <url>%2F2018%2F01%2F15%2Fk8s%2Fk8s-first-md%2F</url>
    <content type="text"><![CDATA[首先， Kubernetes(k8s)是一个全新的基于容器(docker/Rocket)技术的分布式架构解决方案。其次，是一个开放的开发平台，不同的是没有限定任何变成接口、语言、框架，可以很简单的将系统映射为k8s的Service。最后， 是一个一站式的完备的分布式系统支撑平台，k8s具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租户的应用支撑能力、透明的服务注册和发现机制、内建智能负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多粒度的资源配额管理能力。同时提供了涵盖开发、部署测试、运维监控在内的各个环节的管理工具。 1. Master(主节点)组成： 1）APIServer： 负责对外提供 RESTful 的 k8s API服务，它是系统管理指令的统一入口，任何对资源进行增删改查的操作都要交给APIServer处理后再提交给etcd2）scheduler： 负责调度pod到合适的Node上3）Controller manager： 负责管理资源控制器（每个资源一般都对应有一个控制器）4）etcd： 存储各个资源的状态，从而实现了Restful的API 2. Node(节点)组成：1）Runtime： 指的是容器运行环境2）kube-proxy： 服务发现和反向代理功能3）kubelet： 是Master在每个Node节点上面的agent， 负责维护和管理该Node上面的由k8s创建的所有容器 创建过程：1）创建： k8s在物理机、虚拟机或其他云服务资源上创建一个 node 对象， 并对其进行一系列健康检查（是否可以联通、服务是否正确启动、是否可以创建pod等），然后在集群中标记其状态。1）管理： k8s master 通过 Node Controller 管理集群内 node 的信息同步、生命周期等；1）注册: k8s 推荐自注册， 由 kubelet 向 Apiserver 注册自己， 也可以手动注册。 3. Pod在 k8s 中， Pod 是其基本操作单元，也是应用运行的载体。Pod 包含一个或者多个相关的容器（可以看成应用层的逻辑宿主机）。Pod 可以认为是容器的一种延伸扩展，一个Pod也是一个隔离体，而Pod内部包含的一组容器又是共享的。除此之外，Pod中的容器可以访问共同的数据卷来实现文件系统的共享。 Pod 同 docker 一样， 通过数据卷挂载来实现数据持久化（本地、网络等数据卷）。Pod 封装 docker 的目的： docker 容器通信受 docker 网络机制限制（–link），通过 Pod 概念将容器组合在一个虚拟主机内，实现容器通过 localhost 通信（共享 PID 命名空间，网络命名空间，主机名，存储卷等，实现进程通信等）。 Pod 定义： 通过Yaml或Json格式的配置文件来完成, 示例如下：123456789101112131415apiVersion: v1kind: Podmetadata: name: redis-slave labels: name: redis-slavespec: containers: - name: slave image: kubeguide/guestbook-redis-slave command： [&apos;sh&apos;] env: - name: GET_HOSTS_FROM value: env ports: Pod 基本操作： 增：kubectl create -f xxx.yaml删： kubectl delete pod yourPodName 改： kubectl replace /path/to/yourNewYaml.yaml查： kubectl get pod yourPodName， kubectl describe pod yourPodName 4. LabelLabel定义如 Pod、Service、RC、Node 等对象的可识别属性（key/value 键值对），用来对它们进行管理和选择，可以如上面示例那样定义以供创建时附加到对象，也可以在对象创建后通过API进行管理。通过 selector 来进行 label 选择，进行资源之间的关联。如下代码所示， 将该资源与 name： redis-slave 的资源进行关联。12selector: name: redis-slave 5. Replication Controller（RC）用于定义 Pod 副本的数量， 在Master内，Controller Manager进程通过RC的定义来完成Pod的创建、监控、启停等操作。多停少启，保证集群中运行着用户期望的副本数量。与 Pod 类似， 通过 yaml 或 json 配置文件来定义。示例如下， 相比 Pod 定义， kind 变为 ReplicationController， 另外多了 replicas， 以及 Label 选择器 selector。 同时在 template 中定义了 Pod， 由于 RC 特性，通常通过这种形式来创建资源。123456789101112131415161718192021222324apiVersion: v1kind: ReplicationControllermetadata: name: redis-slave labels: name: redis-slavespec: replicas: 3 selector: name: redis-slave template: # template 内定义 Pod， metadata: name: redis-slave labels: name: redis-slave spec: containers: - name: slave image: kubeguide/guestbook-redis-slave command： [&apos;sh&apos;] env: - name: GET_HOSTS_FROM value: env ports: 6. Deployment 后续发展中，出现了 Replica Set – 下一代Replication Controller。相比与 RC selector 的 key/value， RS 还支持集合操作（in,notin ..etc）,后续肯定会加入更多功能.Deployment使用了Replica Set，是更高一层的概念。同时，与 RC 相比， Deployment 拥有更加灵活强大的升级、回滚功能。除非需要自定义升级功能或根本不需要升级 Pod，所以推荐使用 Deployment 而不直接使用Replica Set.Deployment 的定义 与 RC 类似， 主要变化：12apiVersion: extensions/v1beta1kind: Deployment 7. Service（服务）Service 是一种抽象概念，它定义了一个 Pod 逻辑集合以及访问它们的策略。Service 可以看作一组提供相同服务的 Pod 的对外访问接口， 即 Pod 组成的集群。在受到 RC 调控的时候，Pod副本是变化的，对应的虚拟 IP 也是变化的，但 Service 的 Cluster IP 地址是 Kubernetes 系统中的虚拟IP地址(虚拟IP的范围通过k8s API Server的启动参数 –service-cluster-ip-range=19.254.0.0/16配置)，由系统动态分配，在销毁该 Service 之前，这个 IP 地址都不会再变化了。这样， Service就可以作为 Pod 的访问入口，起到代理服务器的作用（同时可以代理 k8s 外部的服务），而对于访问者来说，通过Service进行访问，无需直接感知 Pod。 虚拟 IP 属于 k8s 内部的虚拟网络，外部是寻址不到的。在 k8s 系统中，实际上是由 k8s Proxy组件负责实现虚拟 IP 路由和转发的，所以k8s Node中都必须运行了k8s Proxy，从而在容器覆盖网络之上又实现了k8s层级的虚拟转发网络。将服务发布至外部网络访问方式 由于 pod 会随时销毁重建， 所以 k8s 会根据 Service 关联到 Pod 的 PodIP 信息组合成一个 Endpoints，用来相互衔接， 并且 Endpoints 会随着 pod 的变化而变化 8. Volume（存储卷）k8s 的 Volume 概念与 Docker 的 Volume 比较类似，但不完全相同， 有本地、网络、信息等几种类型的数据卷。 9. 简单创建资源流程假设有 Deployment 定义文件 deployment-demo.yaml 和 Service 定义文件 service-demo.yaml123$ kubectl create deployment-demo.yaml # 创建控制器和 Pod$ kubectl create service-demo.yaml # 创建 service 和 endpoints$ kubectl get all # 查看所有资源信息 参考： kubernetes入门Kubernetes核心概念总结k8s 概念Accessing Kubernetes Pods from Outside of the Cluster]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小游戏目录结构]]></title>
    <url>%2F2018%2F01%2F14%2Fwechat_game%2Fdir-structure-md%2F</url>
    <content type="text"><![CDATA[本文主要讲述， 如何快速创建一个小游戏项目并且针对其目录结构进行简单讲解。 1. 创建项目首先新建项目，目前小游戏不提供公开注册，可点击体验小游戏使用无 AppID 模式（创建时如果建立快速启动模板，需要选择一个空的目录）。 2. 微信预览选择建立快速启动模板后，将会生成一个小游戏项目，并在开发工具中打开，这时点击开发工具右上角的预览按钮，会生成对应二维码，微信扫码即可。 3. 目录结构./audio: 音频目录文件 ./images: 图片文件目录 ./js: 主要源代码目录 ./game.js: 主入口文件 ./game.json: 配置文件 12345678910111213141516171819./js├── base // 定义游戏开发基础类│ ├── animatoin.js // 帧动画的简易实现│ ├── pool.js // 对象池的简易实现│ └── sprite.js // 游戏基本元素精灵类├── libs│ ├── symbol.js // ES6 Symbol简易兼容│ └── weapp-adapter.js // 小游戏适配器├── npc│ └── enemy.js // 敌机类├── player│ ├── bullet.js // 子弹类│ └── index.js // 玩家类├── runtime│ ├── background.js // 背景类│ ├── gameinfo.js // 用于展示分数和结算界面│ └── music.js // 全局音效管理器├── databus.js // 管控游戏状态└── main.js // 游戏入口主函数 源码分析：参考 segmentfault的一篇文章]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>wechat_game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发工具 linux 运行]]></title>
    <url>%2F2018%2F01%2F14%2Fwechat_game%2Fprepare%2F</url>
    <content type="text"><![CDATA[首先，微信小程序开发工具是用nw.js实现的，nw.js(直接从DOM中调用所有的Node.js模块)本身是跨平台的，但是微信只出了开发工具的windows和mac版。下面介绍 linux 系统如何运行开发工具， 以 ubuntu 为例。 1.nw下载nwjs sdk（需要devtool的支援） 压缩包之后解压; 2.设置 path 变量；123$ vim ~/.bashrc # 视个人情况选择文件# 加入步骤一中解压目录， # 例如： export PATH=&quot;$PATH:/home/kk/Downloads/nwjs-sdk-v0.27.4-linux-x64&quot; 3.package.nw在 windows 机器安装开发工具， 找到安装目录，将 package.nw 文件夹拷入 ubuntu 系统； 4.运行12$ cd package.nw$ nw .]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>wechat_game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next]]></title>
    <url>%2F2017%2F12%2F23%2Fhexo-next%2F</url>
    <content type="text"><![CDATA[使用 hexo - next 搭建 github pages 注意事项next version： 5.1.3 文件内容只是一些比较碎的注意事项， 详细流程请参照： next 官网 1. 更换 next 主题123$ hexo init site_name # 创建你的 hexo 项目目录$ cd site_name$ git clone https://github.com/iissnan/hexo-theme-next themes/next # 下载主题 此时，项目目录下有两个 _config.yml 配置文件： ./_config.yml # 站点配置文件 ./themes/next/_config.yml # 主题配置文件然后修改站点配置文件 theme: next 即可 2. 部署项目至 your_user_name.github.io首先， 在 github 创建名为 your_user_name.github.io 的项目然后， 在 站点配置文件 加入或配置 1234deploy: type: git branch: master repo: https://github.com/your_user_name/your_user_name.github.io.git 最后， 开始将 hexo 项目推至 github pages 123$ hexo clean$ hexo generate$ hexo deploy 3. 域名配置两种方案： 方案一： 在 your_user_name.github.io 项目中点击 setting, 配置 custom domain （缺点： 每次 deploy 需要重新配置）方案二： 在 hexo 项目 source 目录下， 创建 CNAME 文件存储域名 4. 静态文件存放由于每次 deploy 都会生成新的 ./.deploy 文件夹并推送至远端，所以类似 images、CNAME、README 文件都要放在 source 文件夹下， 否则将不会推送至远端。 5. 文件内容头说明在每篇文章的头部都会有说明信息供解析， 不多说， 看示例123456---title: Hello Worlddate: 2017-12-16categories: testtags: [test]--- 6. 首页 read more 设置在 *.md 文件中加入 &lt;!-- more --&gt;， 自由控制显示内容， 其他方式不做推荐，不做介绍 7. 语言设置语言设置最好设置固定语言（个人推荐）， 实测如果不设置，可能会出现乱七八槽的语言；站点配置文件1language: en 8. gitment首先， 在 github developer setting Register a new OAuth application123application name # 随意Homepage URL # https://your_user_name.github.io || custom domainAuthorization callback URL # https://your_user_name.github.io || custom domain 其中， 两个 URL 视需求而定， 暂不支持多URL；创建后会生成 client_id、client_secret 供使用 然后， 创建 一个项目 gitment-comments ， 项目名随意， 下面配置会用到，用来存储回复内容；最后， 在 主题配置文件中配置：12345678910111213gitment: enable: true mint: true count: true lazy: false cleanly: false language: # Force language, or auto switch by theme github_user: # your user name github_repo: gitment-comments # 存储回复内容的项目名称 client_id: # client_id client_secret: # client_secet proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 9. 搜索功能推荐本文章推荐使用 local search 1$ npm install hexo-generator-searchdb --save # 安装插件 站点配置文件（不做解释）：12345search: path: search.xml field: post format: html limit: 10000 主题配置文件：1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy-入门教程]]></title>
    <url>%2F2017%2F12%2F23%2Fweb-spider%2Fscrapy-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。本系列所有文档均已基于 linux 操作系统 1. 安装1$ pip install Scrapy]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
